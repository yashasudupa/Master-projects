<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Otawa: Semantic Instructions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Otawa
   &#160;<span id="projectnumber">0.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__sem.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Semantic Instructions</div>  </div>
</div><!--header-->
<div class="contents">

<p>OTAWA provides an abstraction layer between the actual binary program and static analyses.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structotawa_1_1sem_1_1inst.html">otawa::sem::inst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure class represents an instruction in the semantics representation of machine instruction.  <a href="structotawa_1_1sem_1_1inst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classotawa_1_1sem_1_1Printer.html">otawa::sem::Printer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classotawa_1_1sem_1_1Printer.html" title="Printer class for semantic instructions (resolve the generic register value to the their real platfor...">Printer</a> class for semantic instructions (resolve the generic register value to the their real platform name).  <a href="classotawa_1_1sem_1_1Printer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classotawa_1_1sem_1_1PathIter.html">otawa::sem::PathIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator allows easily to traverse all execution paths of a block of semantic instructions.  <a href="classotawa_1_1sem_1_1PathIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4fddd7406e5dc14e06b6750e47da105a"><td class="memItemLeft" align="right" valign="top">cond_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga4fddd7406e5dc14e06b6750e47da105a">otawa::sem::invert</a> (cond_t cond)</td></tr>
<tr class="memdesc:ga4fddd7406e5dc14e06b6750e47da105a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the given condition.  <a href="group__sem.html#ga4fddd7406e5dc14e06b6750e47da105a">More...</a><br /></td></tr>
<tr class="separator:ga4fddd7406e5dc14e06b6750e47da105a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa6f455e43930e49639c5eb143dad92f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gafa6f455e43930e49639c5eb143dad92f">otawa::sem::size</a> (type_t type)</td></tr>
<tr class="memdesc:gafa6f455e43930e49639c5eb143dad92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the given type.  <a href="group__sem.html#gafa6f455e43930e49639c5eb143dad92f">More...</a><br /></td></tr>
<tr class="separator:gafa6f455e43930e49639c5eb143dad92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>OTAWA provides an abstraction layer between the actual binary program and static analyses. </p>
<p>This abstraction is composed of generic information about the processed instruction: type of instruction, target for branch instruction, read and writtent registers, and so on.</p>
<p>To perform value or interval analysis, we need to understand the processing of instructions. To maintain this abstraction layer, OTAWA provides with some architecture plugins a way to translate instruction into a list of architecture-independent instructions to let value analyses to be independent of the actual architecture.</p>
<h1><a class="anchor" id="sem-set"></a>
Semantics Instruction Set</h1>
<p>Designing a language to describe any instruction set is may an impossible task. In the opposite, our semantics language has for goal to allow to perform analyses while retaining only important things for such a task: basic arithmetics and comparison for integer and address and integer computation, minimal flow of control to allow fast analysis.</p>
<p>Basically, a machine instruction I is translated into a block of n semantic instructions [i0, i1, i2, ..., in-1]. To interpret a semantic block, one has to consider a semantic instruction counter, p. At beginning of the interpretation, p = 0. According to the interpreted instructions, p is simply incremented (+1) to perform sequential execution, or changed by adding a positive quantity n to avoid executing some instructions. Notice that n &gt;= 0 induces that no loop can appear in the interpretation of semantic block and hence no fix point is required. The execution stops as soon as p &gt;= n.</p>
<p>A interpretation of a semantic i, |[i]|, can be viewed as a function taking as input (p, s) with s the state of the program and producing a new (p', s'):</p>
<p>|[i]|: (p, s) -&gt; (p', s')</p>
<p>The state s is a an instance of possible states, that is, of functions mapping registers R, temporaries T and memory addresses A to a value in domain V:</p>
<p>S: R U T U A -&gt; V</p>
<p>Set of registers depends on the underlying architecture but is mapped to IN. Temporaries are a subset of negative integers but A currently represents address on 32-bits. For the remaining of the document, s[i] represents the value of V in the state s that matches i, that may be a register, a temporary or an address. s[x / y] represents a new state where value of y is x, that is, s' = s[x / y] = lambda i. if i = y then x else s[i].</p>
<p>The algorithm to interpret a semantic block follows (s0 is the initial state): </p><div class="fragment"><div class="line">p &lt;- 0</div><div class="line">s &lt;- s0</div><div class="line">WHILE i &lt; n DO</div><div class="line">   (p, s) &lt;- |[ip]| (p, s)</div></div><!-- fragment --><p>The following sections describes the semantics of each instruction.</p>
<h1><a class="anchor" id="sem-set-comp"></a>
Computation Instructions</h1>
<p>Basically, our semantic instructions have three operands and works with registers. The first operand d is the target registers to store the result and next ones represents source operands (a and b). The following arithmetics operations exists: </p><ul>
<li>ADD &ndash; addition, </li>
<li>SUB &ndash; subtraction, </li>
<li>SHL &ndash; logical shift left, </li>
<li>SHR &ndash; logical shift right, </li>
<li>ASR &ndash; arithmetic shift right, </li>
<li>AND &ndash; binary and, </li>
<li>OR &ndash; binary inclusive or, </li>
<li>XOR &ndash; binary inclusive xor, </li>
<li>MUL &ndash; signed multiplication, </li>
<li>MULU &ndash; unsigned multiplication, </li>
<li>MULH &ndash; higher order bits of multiplication, </li>
<li>DIV &ndash; signed division, </li>
<li>DIVU &ndash; unsigned division, </li>
<li>MOD &ndash; signed integer division remainder, </li>
<li>MODU &ndash; unsigned integer division remainder.</li>
</ul>
<p>The following instructions represents unary operations applied on the a register and stores the result on the d register. </p><ul>
<li>NEG &ndash; sign negation, </li>
<li>NOT &ndash; binary complement.</li>
</ul>
<p>Below is given the semantics of each instruction where: </p><ul>
<li>a, b, c represents registers, </li>
<li>i represents 32-bits immediate value, </li>
<li>operators applies on unsigned values except if they are followed by "+".</li>
</ul>
<div class="fragment"><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#adb9fb4054c515438b8a591ba8202f3fe">add</a> (d, a, b)]| (p, s) = (p + 1, s[s[a] +   s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a32e916d8f8298cc6473dfd79ae2a8c5b">sub</a> (d, a, b)]| (p, s) = (p + 1, s[s[a] -   s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#ae0e5cc6bdb2ef57a0e7c8ab185e2f7a4">shl</a> (d, a, b)]| (p, s) = (p + 1, s[s[a] &lt;&lt;  s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#abdca765a6528c8921371baac8e8bf08e">shr</a> (d, a, b)]| (p, s) = (p + 1, s[s[a] &gt;&gt;  s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#ad68a4e82f86a9f28dfde712e0aa18960">asr</a> (d, a, b)]| (p, s) = (p + 1, s[s[a] &gt;&gt;+ s[b] / d])</div><div class="line">|[and (d, a, b)]| (p, s) = (p + 1, s[s[a] &amp;   s[b] / d])</div><div class="line">|[or  (d, a, b)]| (p, s) = (p + 1, s[s[a] |   s[b] / d])</div><div class="line">|[xor (d, a, b)]| (p, s) = (p + 1, s[s[a] ^   s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a6980b4fe7c0e70a842c5b04c7116cfd1">mul</a> (d, a, b)]| (p, s) = (p + 1, s[s[a] *   s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#ad071e40def4f5f9e602c8b3508a17b45">mulu</a>(d, a, b)]| (p, s) = (p + 1, s[s[a] *+  s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a0f533efac0f6df996a15fa1b22299df7">mulh</a>(d, a, b)]| (p, s) = (p + 1, s[(s[a] *  s[b]) &gt;&gt; bitlength(d) / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#adda619e31879fe7ede81880b873dfaa3">div</a> (d, a, b)]| (p, s) = (p + 1, s[s[a] /   s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#ae1748ea0ddb1047b8a13d4543235900f">divu</a>(d, a, b)]| (p, s) = (p + 1, s[s[a] /+  s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#ade65f9b2297e50d790fa7c4bf3502827">mod</a> (d, a, b)]| (p, s) = (p + 1, s[s[a] %   s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#aac7ff49ab9c69b3f9442de403538ac9a">modu</a>(d, a, b)]| (p, s) = (p + 1, s[s[a] %+  s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a35bc28607961d226a358cc48c57ad91c">neg</a> (d, a)   ]| (p, s) = (p + 1, s[-s[a]         / d])</div><div class="line">|[not (d, a)   ]| (p, s) = (p + 1, s[~s[a]         / d])</div></div><!-- fragment --><h1><a class="anchor" id="sem-set"></a>
Semantics Instruction Set</h1>
<p>There are four set instructions: </p><ul>
<li>to transfer content of a register to another one, <code>set</code>, </li>
<li>to get a constant 32-bits value in a register, <code>seti</code>, </li>
<li>to assign undefined T value to a register, <code>scratch</code>, </li>
<li>to set the page of an address for multi-address space architectures, <code>setp</code> (very rarely used).</li>
</ul>
<p>Their semantics is described below (i is a 32-bits value):</p>
<div class="fragment"><div class="line">|[<span class="keyword">set</span>    (d, a)]| (p, s) = (p + 1, s[s[a] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a92ae1504877a381066787a60ca1b19b8">seti</a>   (d, i)]| (p, s) = (p + 1, s[i / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a979bfff7bce48eb24c7534da388054c9">scratch</a>(d)   ]| (p, s) = (p + 1, s[T / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a3a7757072a433808bced30bde50f7800">setp</a>   (d, i)]| (p, s) = (p + 1, s[p :: s[d] / d])</div></div><!-- fragment --><h1><a class="anchor" id="sem-flow"></a>
Flow Instructions</h1>
<p>In semantic instructions, there are two types of control flow: machine flow corresponds to PC assignment in the underlying instruction set and is supported by CFG; semantic flow that controls the execution flow of semantic instruction. The only instruction concerning the machine control flow is <code>branch</code> that gives the new address stored in the PC but it doesn't change the semantic instruction counter p.</p>
<p>The semantic control flow is handled by two instruction, <code>cont</code> that stops the execution and <code>if</code> that makes following instructions optional. The condition used in <code>if</code> is generated from a comparison result, a ~ b (a compared to b), generated by either a <code>cmp</code> instruction, or  instruction. Then the <code>if</code> statement exploits the comparison results to apply one of the following condition: </p><ul>
<li>EQ &ndash; a == b </li>
<li>LT &ndash; a &lt; b </li>
<li>LE &ndash; a &lt;= b </li>
<li>GE &ndash; a &gt;= b </li>
<li>GT &ndash; a &gt; b </li>
<li>NE &ndash; a != b </li>
<li>ANY_COND &ndash; do not know anything (recall we are performing static analysis). </li>
<li>ULT &ndash; a &lt; b </li>
<li>ULE &ndash; a &lt;= b </li>
<li>UGE &ndash; a &gt;= b </li>
<li>UGT &ndash; a &gt; b</li>
</ul>
<p>Below is the semantics of the flow instructions (c is a condition and c[a] returns true if condition c is satisfied in register a):</p>
<div class="fragment"><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a2a0cbe60cdcf4992f11b68e4db09fbdc">branch</a>(a)       ]| (p, s) = (p + 1, s)                <span class="comment">// PC &lt;- s[a]</span></div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a23bf65c6b381d4321ac3b32997ba278e">cmp</a>   (d, a, b) ]| (p, s) = (p + 1, s[s[a] ~+ s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a9a878a09c263dd385bda616e732af1bf">cmpu</a>  (d, a, b) ]| (p, s) = (p + 1, s[s[a] ~  s[b] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#ad4dbe47c3ab184149bd50a94e39db1a8">cont</a>            ]| (p, s) = (n, s)</div><div class="line">|[<span class="keywordflow">if</span>    (c, a, k) ]| (p, s) = (<span class="keywordflow">if</span> c[a] then p + 1 <span class="keywordflow">else</span> p + k, s)</div></div><!-- fragment --><h1><a class="anchor" id="sem-mem"></a>
Memory Access Instruction</h1>
<p>There are only two instructions used to perform memory access: </p><ul>
<li><code>load</code> allows to get a value from memory using its address and its type, </li>
<li><code>store</code> allows to store a register value to a memory address using the given type.</li>
</ul>
<p>Notice that the types are required to realize the bytes modified in memory and to generate correct value in register (including sign extension). The types may be one of: </p><ul>
<li>int8 &ndash; signed integer on 8-bits, </li>
<li>int16 &ndash; signed integer on 16-bits, </li>
<li>int32 &ndash; signed integer on 32-bits, </li>
<li>int64 &ndash; signed integer on 64-bits, </li>
<li>uint8 &ndash; unsigned integer on 8-bits, </li>
<li>uint16 &ndash; unsigned integer on 16-bits, </li>
<li>uint32 &ndash; unsigned integer on 32-bits, </li>
<li>uint64 &ndash; unsigned integer on 64-bits.</li>
</ul>
<p>The semantics of these instructions follows (t is the type, s(t) represents access to state with type t): </p><div class="fragment"><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#a6844edc409329a16f8aa2199baad2ff4">load</a> (d, a, t)]| (p, s) = (p + 1, s[s(t)[s[a] / d])</div><div class="line">|[<a class="code" href="namespaceotawa_1_1sem.html#aaaa8807f18703719957371a1309cdbd2">store</a>(d, a, t)]| (p, s) = (p + 1, s(t)[d / s[b]])</div></div><!-- fragment --><h1><a class="anchor" id="sem-spec"></a>
Special Instruction</h1>
<p>There is also a  semantics instruction kind that must be used by instruction effects not tractable with the current semantics instruction set. One using the SPEC instructions must be aware that standard usual analyses will not cope with such instructions: they will need to be customized. Therefore, the semantics of <code>spec</code> is undefined.</p>
<h1><a class="anchor" id="sem-reg"></a>
Register and Temporaries</h1>
<p>Operators used in the instruction (a, b and d) represents unique representation of registers (as returned by Register::platformNumber()) for positive number or temporaries when negative numbers are used.</p>
<p>Temporary values are useful when the semantics expression of an instruction is complex and requires several temporary results. To alleviate the management of temporaries, they are easy identified as they are represented as negative numbers and their maximum number is provided by the Process::tempMax(). Please, notice that the liveness of a temporary must not expand out of the semantics block of an instruction !</p>
<h1><a class="anchor" id="sem-anal"></a>
Building Analyses</h1>
<p>Static analyses using instruction semantics are usually called data-flow analysis. Using Abstact Interpretation, the interpretation domain is usually an abstraction of the program variables state. The state includes usually the value of the registers (simply identified by the register platform number) and the addresses of used locations in memory. Register numbers and memory location addresses grouped together forms the address set.</p>
<p>So, the state becomes usually maps from addresses to value. OTAWA provides already several representations for these maps.The next step is to define the abstraction of the values: values are stored in registers and in memory and must be specialized according to the performed analysis. For example, the CLP (Cycle Linear Progression) analysis, the values are represented as triplets (b, d, n) representing a set of integers (and adresses) from the set {b + i d / 0 &lt;= i &lt; n}. But, it may be any value you want, adapted to your analysis. Whatever, one must remark that addresses are usually storable in registers and in memory, the value set must provides a way to represent them.</p>
<p>The usual map representations provide already functions to perform abstract interpretation (bottom value, initial value, update, join, etc). In the case of the value, you have also to provide function to perform abstract interpretation but also functions to interpret the different semantic instructions.</p>
<p>To help the developer supports the multiple execution path of a semantic bloc, one can use the class <a class="el" href="classotawa_1_1sem_1_1PathIter.html">otawa::sem::PathIter</a> that works like a usual iterator but provides also indications of the executed paths and instructions: </p><ul>
<li>op, d, a, b, cst, reg, addr &ndash; access to instruction description, </li>
<li>pathEnd() &ndash; true if execution is at end, </li>
<li>isCond() &ndash; true if the current instruction is a <code>if</code>, meaning that two paths will start from this point.</li>
</ul>
<p>A common way to use <a class="el" href="classotawa_1_1sem_1_1PathIter.html">otawa::sem::PathIter</a> is to maintain a stack of states where the current state is pushed when an <code>if</code> is found and a state is popped when an execution path ends. The different states obtained at each end of an execution path can be joined: </p><div class="fragment"><div class="line">genstruct::Vector&lt;State&gt; stack;</div><div class="line">State s = initial_state, result = bottom_state;</div><div class="line">stack.push(s);</div><div class="line"><span class="keywordflow">for</span>(sem::PathIter i(machine_instruction); i; i++) {</div><div class="line">        <span class="keywordflow">if</span>(i.pathEnd()) {</div><div class="line">                result = join(result, s);</div><div class="line">                s = stack.pop();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> {</div><div class="line">                <span class="keywordflow">if</span>(i.isCond())</div><div class="line">                stack.push(s);</div><div class="line">        s = apply(i, s);</div><div class="line">        }</div><div class="line">}</div><div class="line"><span class="keywordflow">return</span> result;</div></div><!-- fragment --><p>A specific processing is devoted to SPEC instructions. A convenient analysis must let its user to specialize it in order to support these instructions. To achieve this goal, it must provide in the analysis a virtual function that is called each time the SPEC instruction is interpreted. It would be useful if this function takes as parameter the real instruction, the semantics instruction and the current abstract state. In the initial analysis, this function simply do nothing but it lets customizer to overload it in order to customize the interpretation. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4fddd7406e5dc14e06b6750e47da105a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cond_t otawa::sem::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceotawa_1_1sem.html#ab00dc7f973a8b9fe72e3079d43a7fbff">cond_t</a>&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the given condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to invert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverted condition. </dd></dl>

<p>References <a class="el" href="namespaceotawa_1_1sem.html#ab00dc7f973a8b9fe72e3079d43a7fbffad740c1e38d7b552cf9c526b7185dcd3f">otawa::sem::ANY_COND</a>, <a class="el" href="namespaceotawa_1_1se.html#a09ea8009bd5f3cf4f108b3224b183111a3568cf9bd76da88272656c3e4c93adfa">otawa::se::EQ</a>, <a class="el" href="namespaceotawa_1_1se.html#a09ea8009bd5f3cf4f108b3224b183111a3c1fd9edee2cbf27f33f78391ede48d4">otawa::se::GE</a>, <a class="el" href="namespaceotawa_1_1se.html#a09ea8009bd5f3cf4f108b3224b183111aa7f8cb542cd7bd35165a6889a5f19dcf">otawa::se::GT</a>, <a class="el" href="namespaceotawa_1_1se.html#a09ea8009bd5f3cf4f108b3224b183111a154f40ebd70434f666184582017a1e60">otawa::se::LE</a>, <a class="el" href="namespaceotawa_1_1se.html#a09ea8009bd5f3cf4f108b3224b183111a5f9947a303c9f8606b18aad6dc4c1a39">otawa::se::LT</a>, <a class="el" href="namespaceotawa_1_1sem.html#ab00dc7f973a8b9fe72e3079d43a7fbffac84add2ed124ab67e85201ccbd5048ff">otawa::sem::MAX_COND</a>, <a class="el" href="namespaceotawa_1_1se.html#a09ea8009bd5f3cf4f108b3224b183111af226885f41650641c91de2bb0dc939b6">otawa::se::NE</a>, <a class="el" href="namespaceotawa_1_1sem.html#ab00dc7f973a8b9fe72e3079d43a7fbffa97cb4244d70b2b034d47f481afeb3d3a">otawa::sem::NO_COND</a>, <a class="el" href="namespaceotawa_1_1se.html#a09ea8009bd5f3cf4f108b3224b183111aabdbb790667f1d9e164169dd1fd27252">otawa::se::UGE</a>, <a class="el" href="namespaceotawa_1_1se.html#a09ea8009bd5f3cf4f108b3224b183111af539df8ccccf92c3172c68bcdd42806e">otawa::se::UGT</a>, <a class="el" href="namespaceotawa_1_1se.html#a09ea8009bd5f3cf4f108b3224b183111afe698ffa10182fdcd6fc45c8df7955aa">otawa::se::ULE</a>, and <a class="el" href="namespaceotawa_1_1se.html#a09ea8009bd5f3cf4f108b3224b183111ad79e0903159acfc769d1ed9799c613ac">otawa::se::ULT</a>.</p>

</div>
</div>
<a class="anchor" id="gafa6f455e43930e49639c5eb143dad92f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int otawa::sem::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceotawa_1_1sem.html#a792fe075979fefd9fd427c1a43344174">type_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td><a class="el" href="classotawa_1_1Type.html" title="This class describes the type of the data in the program. ">Type</a> to get size for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes. </dd></dl>

<p>References <a class="el" href="namespaceotawa.html#a748dbd1eb1a1b4dc04eb9d6160fd669f">otawa::type()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
